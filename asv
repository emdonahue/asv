#!/bin/zsh

#TODO get -h printing global help by redirecting to script

set -o errexit
set -o pipefail
if [[ "${TRACE-0}" == "1" ]]; then set -o xtrace; fi

export LC_COLLATE="${LC_COLLATE:-C}" #Selects the locale for determining sort order of dimensions.

local SOH=$'\001'
local STX=$'\002'
local FS=$'\034'
local GS=$'\035'
local RS='\0'
local FS=$'\036'
local US=$'\037'

asvawk() {
    awk -v"OFS=$FS" -v"ORS=$RS" -v"FS=$FS" -v"RS=$RS" "$@"
}

fieldjoin() {
    local IFS="$FS"
    echo -n "$*"
}

echoheader() {
    local IFS="$FS"
    echo -n "$*$RS"
}

CMD="$1"
[[ $# -ne 0 ]] && shift
case "$CMD" in
    header) #ASV HEADER..., Sets the headers for ASV to the list of HEADERS.
	echoheader "${@:2}"
	tail -z -n+2 "${1:--}"
	;;

    substitute) #PATTERN SUBSTITUTION [ASV], Replaces regex PATTERN with SUBSTITUTION, which may use back references.
	awk -v"OFS=$FS" -v"ORS=$RS" -v"FS=$FS" -v"RS=[$RS$SOH$STX]" -v"SOH=$SOH" -v"STX=$STX" "RT==SOH || RT==STX {printf(RT); next}"'{print}' "${3:--}"
	;;
    
    tokenize) #TOKENS [TOKENS...], Converts each whitespace-separated TOKENS file into a token table and concatenates them all.
	zparseopts -A opts -E -D f
	local FNAMES=${+opts[-f]} #Adds column representing filename in which token was found.

	echo -n "$SOH"
	[[ "$FNAMES" -eq 1 ]] && echo -n "filename$FS"
	echo -n "token$RS"
	echo -n "$STX"
	awk -vFNAMES="$FNAMES" -v'RS=[[:space:]]' -v"OFS=$FS" -v"ORS=$RS" '{printf("%s%s"ORS, FNAMES ? FILENAME OFS : "", $0)}' "$@"
	;;

    tsv2asv) #TSV [HEADER...], Converts TSV into an asv table using HEADERS as the columns. If no HEADERS are supplied, the first row of TSV is used as the header.
	[[ $# -gt 1 ]] && echoheader "${@:2}"
	< "${1:-/dev/fd/0}" tr '\n\t' "$RS$FS"
	;;

    --help|-h|help) #[SUBCOMMAND], Prints help text for SUBCOMMAND. If SUBCOMMAND omitted, prints list of subcommands.
	    [[ $# -eq 0 ]] && echo 'deps - Automatic Makefile generation for data processing pipelines from command line history\nUsage: deps SUBCOMMAND [ARGUMENTS...]\nSubcommands:'
	    grep -E -- "${1:-\\w+}\)\s#" "$0" | sed -E -- "s/^[[:space:]]*([-|[:alpha:]]+)\)\s#([^,]*), (.*)/\1 \2 - \3/" | sed $((${+1}+1))',$ s/^[[:space:]]*/\t/'
	    ;;
    *)
	"$0" help
	[[ -z "$CMD" ]] || exit 1
	;;
esac
